import types
from typing import Any, TypeAlias

from kombu.connection import Connection
from kombu.message import Message as Message
from kombu.messaging import Consumer, Producer
from kombu.utils.objects import cached_property
from typing_extensions import Self

__all__ = ("Management", "Message", "StdChannel", "Transport")

class Implements(dict[str, Any]):
    def __getattr__(self, key: str) -> Any: ...
    def __setattr__(self, key: str, value: Any) -> None: ...
    def extend(self, **kwargs: Any) -> Implements: ...

# Forward reference for Management to avoid name collision with Transport.Management
_ManagementType: TypeAlias = Management

class Management:
    transport: Transport
    def __init__(self, transport: Transport) -> None: ...
    def get_bindings(self) -> list[dict[str, Any]]: ...

class Transport:
    Management: type[Management]

    client: Connection | None
    can_parse_url: bool
    default_port: int | None
    connection_errors: tuple[type[BaseException], ...]
    channel_errors: tuple[type[BaseException], ...]
    driver_type: str
    driver_name: str
    recoverable_connection_errors: tuple[type[BaseException], ...]
    recoverable_channel_errors: tuple[type[BaseException], ...]
    implements: Implements

    def __init__(self, client: Connection, **kwargs: Any) -> None: ...
    def establish_connection(self) -> Any: ...
    def close_connection(self, connection: Any) -> None: ...
    def create_channel(self, connection: Any) -> StdChannel: ...
    def close_channel(self, connection: Any) -> None: ...
    def drain_events(self, connection: Any, **kwargs: Any) -> None: ...
    def heartbeat_check(self, connection: Any, rate: int = ...) -> None: ...
    def driver_version(self) -> str: ...
    def get_heartbeat_interval(self, connection: Any) -> int: ...
    def verify_connection(self, connection: Any) -> bool: ...
    def qos_semantics_matches_spec(self, connection: Any) -> bool: ...
    def on_readable(self, connection: Any, loop: Any) -> None: ...
    def as_uri(
        self,
        uri: str,
        include_password: bool = ...,
        mask: str = ...,
    ) -> str: ...
    def get_manager(self, *args: Any, **kwargs: Any) -> _ManagementType: ...
    def register_with_event_loop(self, connection: Any, loop: Any) -> None: ...
    def unregister_from_event_loop(self, connection: Any, loop: Any) -> None: ...
    @property
    def default_connection_params(self) -> dict[str, Any]: ...
    @cached_property
    def manager(self) -> _ManagementType: ...
    @property
    def supports_heartbeats(self) -> bool: ...
    @property
    def supports_ev(self) -> bool: ...

class StdChannel:
    no_ack_consumers: set[str] | None

    def Consumer(self, *args: Any, **kwargs: Any) -> Consumer: ...  # ty: ignore[invalid-type-form]
    def Producer(self, *args: Any, **kwargs: Any) -> Producer: ...  # ty: ignore[invalid-type-form]
    def get_bindings(self) -> list[dict[str, Any]]: ...
    def after_reply_message_received(self, queue: str) -> None: ...
    def prepare_queue_arguments(
        self, arguments: dict[str, Any] | None, **kwargs: Any
    ) -> dict[str, Any] | None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: types.TracebackType | None,
    ) -> None: ...
