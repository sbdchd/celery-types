from collections.abc import Callable, Generator
from typing import Any

from kombu.asynchronous.timer import Timer
from kombu.utils.objects import cached_property

__all__ = ("Hub", "get_event_loop", "set_event_loop")

READ: int
WRITE: int
ERR: int

def _dummy_context(*args: Any) -> Generator[None, None, None]: ...
def _raise_stop_error() -> None: ...

class Hub:
    READ: int
    WRITE: int
    ERR: int

    timer: Timer
    readers: dict[int, Callable[..., Any]]
    writers: dict[int, Callable[..., Any]]
    on_tick: list[Callable[..., Any]]
    on_close: list[Callable[..., Any]] | None

    def __init__(self, timer: Timer | None = ...) -> None: ...
    def add(
        self,
        fd: int | Any,
        callback: Callable[..., Any],
        flags: int,
        args: tuple[Any, ...] = ...,
        consolidate: bool = ...,
    ) -> None: ...
    def add_reader(
        self, fds: int | Any, callback: Callable[..., Any], *args: Any
    ) -> None: ...
    def add_writer(
        self, fds: int | Any, callback: Callable[..., Any], *args: Any
    ) -> None: ...
    def remove(self, fd: int | Any) -> None: ...
    def remove_reader(self, fd: int | Any) -> None: ...
    def remove_writer(self, fd: int | Any) -> None: ...
    def run_forever(self) -> None: ...
    def run_once(self) -> None: ...
    def call_soon(self, callback: Callable[..., Any], *args: Any) -> Any: ...
    def call_later(
        self, delay: float, callback: Callable[..., Any], *args: Any
    ) -> Any: ...
    def call_at(self, when: float, callback: Callable[..., Any], *args: Any) -> Any: ...
    def call_repeatedly(
        self, delay: float, callback: Callable[..., Any], *args: Any
    ) -> Any: ...
    def close(self, *args: Any) -> None: ...
    def stop(self) -> None: ...
    def reset(self) -> None: ...
    def fire_timers(
        self,
        min_delay: float = ...,
        max_delay: float = ...,
        max_timers: int = ...,
        propagate: tuple[type[Exception], ...] = ...,
    ) -> float: ...
    def create_loop(
        self,
        generator: type[Generator[Any, Any, Any]] = ...,
        sleep: Callable[[float], None] = ...,
        min: Callable[..., Any] = ...,
        next: Callable[..., Any] = ...,
        Empty: type[Exception] = ...,
        StopIteration: type[BaseException] = ...,
        KeyError: type[Exception] = ...,
        READ: int = ...,
        WRITE: int = ...,
        ERR: int = ...,
    ) -> Generator[None, None, None]: ...
    def on_callback_error(
        self, callback: Callable[..., Any], exc: BaseException
    ) -> None: ...
    def repr_active(self) -> str: ...
    def repr_events(self, events: list[tuple[int, int]]) -> str: ...
    @property
    def loop(self) -> Generator[None, None, None]: ...
    @property
    def poller(self) -> Any: ...
    def _create_poller(self) -> Any: ...
    def _close_poller(self) -> None: ...
    def _pop_ready(self) -> Callable[..., Any] | None: ...
    def _unregister(self, fd: int | Any) -> None: ...
    def _remove_from_loop(self, fd: int | Any) -> None: ...
    def _discard(self, fd: int | Any) -> None: ...
    @cached_property
    def scheduler(self) -> Timer: ...

def get_event_loop() -> Hub | None: ...
def set_event_loop(loop: Hub | None) -> Hub | None: ...
