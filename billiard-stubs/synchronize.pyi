from collections.abc import Callable
from multiprocessing.context import BaseContext

__all__ = ["BoundedSemaphore", "Condition", "Event", "Lock", "RLock", "Semaphore"]

class Semaphore:
    def __init__(self, value: int = ..., ctx: BaseContext | None = ...) -> None: ...
    def __enter__(self) -> bool: ...
    def __exit__(self, *args: object) -> None: ...
    def get_value(self) -> int: ...

class BoundedSemaphore(Semaphore):
    def __init__(self, value: int = ..., ctx: BaseContext | None = ...) -> None: ...

class Lock:
    def __init__(self, ctx: BaseContext | None = ...) -> None: ...
    def __enter__(self) -> bool: ...
    def __exit__(self, *args: object) -> None: ...

class RLock:
    def __init__(self, ctx: BaseContext | None = ...) -> None: ...
    def __enter__(self) -> bool: ...
    def __exit__(self, *args: object) -> None: ...

class Condition:
    def __init__(
        self, lock: Lock | RLock | None = ..., ctx: BaseContext | None = ...
    ) -> None: ...
    def notify(self) -> None: ...
    def notify_all(self) -> None: ...
    def wait(self, timeout: float | None = ...) -> bool: ...
    def wait_for(
        self, predicate: Callable[[], bool], timeout: float | None = ...
    ) -> bool: ...
    def __enter__(self) -> bool: ...
    def __exit__(self, *args: object) -> None: ...

class Event:
    def __init__(self, ctx: BaseContext | None = ...) -> None: ...
    def is_set(self) -> bool: ...
    def set(self) -> None: ...
    def clear(self) -> None: ...
    def wait(self, timeout: float | None = ...) -> bool: ...

class Barrier:
    def __init__(
        self,
        parties: int,
        action: Callable[[], object] | None = ...,
        timeout: float | None = ...,
        ctx: BaseContext | None = ...,
    ) -> None: ...
    def wait(self, timeout: float | None = ...) -> int: ...
    def reset(self) -> None: ...
    def abort(self) -> None: ...
    @property
    def parties(self) -> int: ...
    @property
    def n_waiting(self) -> int: ...
    @property
    def broken(self) -> bool: ...
