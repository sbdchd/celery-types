import threading

from billiard.common import TERM_SIGNAL as TERM_SIGNAL
from billiard.common import human_status as human_status
from billiard.common import pickle_loads as pickle_loads
from billiard.common import reset_signals as reset_signals
from billiard.common import restart_state as restart_state
from billiard.compat import get_errno as get_errno
from billiard.compat import mem_rss as mem_rss
from billiard.compat import send_offset as send_offset
from billiard.dummy import Process as DummyProcess
from billiard.einfo import ExceptionInfo as ExceptionInfo
from billiard.exceptions import CoroStop as CoroStop
from billiard.exceptions import RestartFreqExceeded as RestartFreqExceeded
from billiard.exceptions import SoftTimeLimitExceeded as SoftTimeLimitExceeded
from billiard.exceptions import Terminated as Terminated
from billiard.exceptions import TimeLimitExceeded as TimeLimitExceeded
from billiard.exceptions import TimeoutError as TimeoutError
from billiard.exceptions import WorkerLostError as WorkerLostError
from billiard.util import debug as debug
from billiard.util import warning as warning

MAXMEM_USED_FMT: str
SIGKILL = TERM_SIGNAL
RUN: int
CLOSE: int
TERMINATE: int
ACK: int
READY: int
TASK: int
NACK: int
DEATH: int
EX_OK: int
EX_FAILURE: int
EX_RECYCLE: int
LOST_WORKER_TIMEOUT: float
GUARANTEE_MESSAGE_CONSUMPTION_RETRY_LIMIT: int
GUARANTEE_MESSAGE_CONSUMPTION_RETRY_INTERVAL: float
Lock = threading.Lock

class LaxBoundedSemaphore(threading.Semaphore):
    def shrink(self) -> None: ...
    def grow(self) -> None: ...
    def release(self) -> None: ...
    def clear(self) -> None: ...

class MaybeEncodingError(Exception):
    def __init__(self, exc: object, value: object) -> None: ...

class WorkersJoined(Exception): ...

class Worker:
    def after_fork(self) -> None: ...

class PoolThread(DummyProcess):
    daemon: bool
    def on_stop_not_started(self) -> None: ...
    def terminate(self) -> None: ...
    def close(self) -> None: ...

class Supervisor(PoolThread):
    def body(self) -> None: ...

class TaskHandler(PoolThread):
    def body(self) -> None: ...
    def tell_others(self) -> None: ...
    def on_stop_not_started(self) -> None: ...

class TimeoutHandler(PoolThread):
    def body(self) -> None: ...

class ResultHandler(PoolThread):
    def on_stop_not_started(self) -> None: ...
    def body(self) -> None: ...
    def finish_at_shutdown(self, handle_timeouts: bool = ...) -> None: ...

class Pool:
    def shrink(self, n: int = ...) -> None: ...
    def grow(self, n: int = ...) -> None: ...
    def maintain_pool(self) -> None: ...
    def __reduce__(self) -> None: ...
    def close(self) -> None: ...
    def terminate(self) -> None: ...
    def join(self) -> None: ...
    def restart(self) -> None: ...

class ApplyResult:
    def discard(self) -> None: ...
    def handle_timeout(self, soft: bool = ...) -> None: ...

class MapResult(ApplyResult): ...
class IMapIterator: ...
class IMapUnorderedIterator(IMapIterator): ...

class ThreadPool(Pool):
    Process = DummyProcess
    def __init__(self) -> None: ...
