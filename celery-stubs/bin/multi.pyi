from typing import IO, Any

from celery.apps.multi import (
    Cluster as _Cluster,
)
from celery.apps.multi import (
    MultiParser as _MultiParser,
)
from celery.apps.multi import (
    NamespacedOptionParser as _NamespacedOptionParser,
)
from celery.bin.base import CeleryCommand
from celery.utils.term import colored

__all__ = ("MultiTool",)

class TermLogger:
    retcode: int
    splash_text: str
    splash_context: dict[str, Any]
    stdout: IO[str]
    stderr: IO[str]
    nosplash: bool
    quiet: bool
    verbose: bool
    no_color: bool

    @property
    def colored(self) -> colored: ...  # ty: ignore[invalid-type-form]
    def setup_terminal(
        self,
        stdout: IO[str] | None,
        stderr: IO[str] | None,
        nosplash: bool = False,
        quiet: bool = False,
        verbose: bool = False,
        no_color: bool = False,
        **kwargs: Any,
    ) -> None: ...
    def ok(self, m: str, newline: bool = True, file: IO[str] | None = None) -> int: ...
    def say(
        self, m: str, newline: bool = True, file: IO[str] | None = None
    ) -> None: ...
    def carp(
        self, m: str, newline: bool = True, file: IO[str] | None = None
    ) -> int: ...
    def error(self, msg: str | None = None) -> int: ...
    def info(self, msg: str, newline: bool = True) -> None: ...
    def note(self, msg: str, newline: bool = True) -> None: ...
    def usage(self) -> None: ...
    def splash(self) -> None: ...

class MultiTool(TermLogger):
    MultiParser: type[_MultiParser]
    OptionParser: type[_NamespacedOptionParser]
    reserved_options: list[tuple[str, str]]
    env: dict[str, str] | None
    cmd: str | None
    fh: IO[str]
    prog_name: str
    commands: dict[str, Any]

    @property
    def OK(self) -> int: ...
    @property
    def DOWN(self) -> int: ...
    @property
    def FAILED(self) -> int: ...
    def __init__(
        self,
        env: dict[str, str] | None = None,
        cmd: str | None = None,
        fh: IO[str] | None = None,
        stdout: IO[str] | None = None,
        stderr: IO[str] | None = None,
        **kwargs: Any,
    ) -> None: ...
    def Cluster(self, nodes: list[Any], cmd: str | None = None) -> _Cluster: ...
    def execute_from_commandline(
        self, argv: list[str], cmd: str | None = None
    ) -> int: ...
    def validate_arguments(self, argv: list[str]) -> bool: ...
    def call_command(self, command: str, argv: list[str]) -> int: ...
    def cluster_from_argv(
        self, argv: list[str], cmd: str | None = None
    ) -> _Cluster: ...
    def start(self, cluster: _Cluster) -> int: ...
    def stop(self, cluster: _Cluster, sig: int, **kwargs: Any) -> int: ...
    def stopwait(self, cluster: _Cluster, sig: int, **kwargs: Any) -> int: ...
    stop_verify: Any  # alias for stopwait
    def restart(self, cluster: _Cluster, sig: int, **kwargs: Any) -> int: ...
    def names(self, cluster: _Cluster) -> None: ...
    def get(self, wanted: str, *argv: str) -> int: ...
    def show(self, cluster: _Cluster) -> None: ...
    def expand(self, template: str, *argv: str) -> None: ...
    def help(self, *argv: str) -> None: ...
    def kill(self, cluster: _Cluster) -> None: ...
    def on_node_start(self, node: Any) -> None: ...
    def on_node_restart(self, node: Any) -> None: ...
    def on_node_shutdown_ok(self, node: Any) -> None: ...
    def on_node_status(self, node: Any, retval: int) -> None: ...
    def on_node_signal(self, node: Any, sig: int) -> None: ...
    def on_node_signal_dead(self, node: Any) -> None: ...
    def on_node_down(self, node: Any) -> None: ...
    def on_child_spawn(self, node: Any, argstr: str, env: dict[str, str]) -> None: ...
    def on_child_signalled(self, node: Any, signum: int) -> None: ...
    def on_child_failure(self, node: Any, retcode: int) -> None: ...
    def on_send_signal(self, node: Any, sig: int) -> None: ...
    def on_still_waiting_for(self, nodes: list[Any]) -> None: ...
    def on_still_waiting_progress(self, nodes: list[Any]) -> None: ...
    def on_still_waiting_end(self) -> None: ...
    def on_stopping_preamble(self, nodes: list[Any]) -> None: ...

multi: CeleryCommand
