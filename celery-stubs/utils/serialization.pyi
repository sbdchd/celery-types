from collections.abc import Callable
from typing import Any

__all__ = (
    "UnpickleableExceptionWrapper",
    "create_exception_cls",
    "find_pickleable_exception",
    "get_pickleable_etype",
    "get_pickleable_exception",
    "get_pickled_exception",
    "strtobool",
    "subclass_exception",
)

STRTOBOOL_DEFAULT_TABLE: dict[str, bool]

class UnpickleableExceptionWrapper(Exception):
    exc_module: str | None
    exc_cls_name: str | None
    exc_args: tuple[Any, ...] | None

    def __init__(
        self,
        exc_module: str,
        exc_cls_name: str,
        exc_args: tuple[Any, ...],
        text: str | None = None,
    ) -> None: ...
    @classmethod
    def from_exception(cls, exc: Exception) -> UnpickleableExceptionWrapper: ...
    def restore(self) -> Exception: ...

def b64encode(s: bytes) -> bytes: ...
def b64decode(s: bytes) -> bytes: ...
def base64encode(s: bytes, altchars: bytes | None = None) -> bytes: ...
def base64decode(
    s: bytes, altchars: bytes | None = None, validate: bool = False
) -> bytes: ...
def bytes_to_str(s: bytes | str) -> str: ...
def str_to_bytes(s: str | bytes) -> bytes: ...
def strtobool(
    term: str | bool | int | None, table: dict[str, bool] | None = None
) -> bool: ...
def get_pickleable_exception(exc: Exception) -> Exception: ...
def get_pickleable_etype(
    cls: type[Exception], loads: Any = ..., dumps: Any = ...
) -> type[Exception]: ...
def get_pickled_exception(exc: Exception) -> Exception: ...
def jsonify(
    obj: Any,
    builtin_types: tuple[type, ...] = ...,
    key: Any = None,
    keyfilter: Callable[[str], bool] | None = None,
    unknown_type_filter: Callable[[Any], Any] | None = None,
) -> Any: ...
def raise_with_context(exc: Exception) -> None: ...
def find_pickleable_exception(
    exc: Exception,
    loads: Any = ...,
    dumps: Any = ...,
) -> Exception | None: ...
def ensure_serializable(items: list[Any], encoder: Any) -> list[Any]: ...
def create_exception_cls(
    name: str, module: str, parent: type | None = None
) -> type[Exception]: ...
def subclass_exception(
    name: str, parent: type[Exception], module: str
) -> type[Exception]: ...
def itermro(cls: type, stop: type) -> Any: ...
def safe_repr(o: Any, errors: str = "replace") -> str: ...
