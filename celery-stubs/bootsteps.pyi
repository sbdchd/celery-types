from typing import Any, ClassVar

__all__ = ("Blueprint", "ConsumerStep", "StartStopStep", "Step")

from celery.utils.graph import GraphFormatter
from kombu import Consumer
from typing_extensions import override

class StepFormatter(GraphFormatter):
    blueprint_prefix: str
    conditional_prefix: str
    blueprint_scheme: dict[str, str]
    @override
    def label(self, step: Any) -> Any: ...  # pyright: ignore[reportIncompatibleMethodOverride]  # ty: ignore[invalid-method-override]
    @override
    def node(self, obj: Any, **attrs: Any) -> Any: ...
    @override
    def edge(self, a: Any, b: Any, **attrs: Any) -> Any: ...

class Blueprint:
    GraphFormatter = StepFormatter
    name: ClassVar[str | None]
    state: Any
    started: int
    default_steps: set[Any]
    state_to_name: Any
    types: Any
    on_start: Any
    on_close: Any
    on_stopped: Any
    shutdown_complete: Any
    steps: Any
    def __init__(
        self,
        steps: Any | None = ...,
        name: Any | None = ...,
        on_start: Any | None = ...,
        on_close: Any | None = ...,
        on_stopped: Any | None = ...,
    ) -> None: ...
    def start(self, parent: Any) -> None: ...
    def human_state(self) -> str: ...
    def info(self, parent: Any) -> Any: ...
    def close(self, parent: Any) -> None: ...
    def restart(
        self,
        parent: Any,
        method: str = ...,
        description: str = ...,
        propagate: bool = ...,
    ) -> None: ...
    def send_all(
        self,
        parent: Any,
        method: Any,
        description: Any | None = ...,
        reverse: bool = ...,
        propagate: bool = ...,
        args: Any = ...,
    ) -> None: ...
    def stop(self, parent: Any, close: bool = ..., terminate: bool = ...) -> None: ...
    def join(self, timeout: Any | None = ...) -> None: ...
    def apply(self, parent: Any, **kwargs: Any) -> Any: ...
    def connect_with(self, other: Any) -> None: ...
    def __getitem__(self, name: str) -> Any: ...
    def claim_steps(self) -> Any: ...
    def load_step(self, step: Any) -> Any: ...
    @property
    def alias(self) -> Any: ...

class StepType(type):
    name: ClassVar[str | None]
    requires: tuple[type[Step] | str, ...] | None
    def __new__(cls, name: Any, bases: Any, attrs: Any) -> Any: ...

class Step(metaclass=StepType):
    name: ClassVar[str | None]
    label: ClassVar[str | None]
    conditional: bool
    requires: tuple[type[Step] | str, ...]
    last: bool
    enabled: bool
    def __init__(self, parent: Any, **kwargs: Any) -> None: ...
    def include_if(self, parent: Any) -> Any: ...
    def instantiate(self, name: Any, *args: Any, **kwargs: Any) -> Any: ...
    def include(self, parent: Any) -> Any: ...
    def create(self, parent: Any) -> None: ...
    @property
    def alias(self) -> Any: ...
    def info(self, obj: Any) -> None: ...

class StartStopStep(Step):
    obj: Any
    def start(self, parent: Any) -> Any: ...
    def stop(self, parent: Any) -> Any: ...
    def close(self, parent: Any) -> None: ...
    def terminate(self, parent: Any) -> Any: ...
    @override
    def include(self, parent: Any) -> Any: ...

class ConsumerStep(StartStopStep):
    consumers: list[Consumer] | None
    def get_consumers(self, channel: Any) -> list[Consumer]: ...
    @override
    def start(  # pyright: ignore[reportIncompatibleMethodOverride]  # ty: ignore[invalid-method-override]
        self, c: Any
    ) -> None: ...
    @override
    def stop(  # pyright: ignore[reportIncompatibleMethodOverride]  # ty: ignore[invalid-method-override]
        self, c: Any
    ) -> None: ...
    def shutdown(self, c: Any) -> None: ...
